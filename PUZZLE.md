### Q1：深拷贝与浅拷贝

直接拷贝称为浅拷贝，深拷贝在计算机中（堆区）开辟一块新的内存地址用于存放复制的对象在堆区存放的内容，


### Q2: new/delete与malloc/free的区别

1. new/delete是C++操作符，malloc/free是库函数
2. ***new分配内存按照数据类型进行分配，malloc分配内存按照大小分配***
3. new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时 调用对象的析构函数。
   而malloc只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回NULL。
4. new/delete可以重载，而malloc不行
5. **new返回的是指定对象的指针，而malloc返回的是void* ，因此malloc的返回值一般都需要进行类型转化** 
6. 对于数据C++定义new[]专门进行动态数组分配，用delete[]进行销毁。new[]会一次分配内存，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放
   new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL；
   malloc能够直观地重新分配内存使用realloc函数进行内存重新分配实现内存的扩充
   new没有这样直观的配套设施来扩充内存。


### Q3: sizeof与strlen(或length())的区别

前者sizeof返回值的单位是 **字节数** ，后者strlen/length()返回值是 **字节数** 。

strlen是库cstring中的函数，length()是STL容器string的类方法。


### Q4: struct和class区别

在C++中struct和class唯一的区别在于默认的访问权限不同

区别：
- struct默认权限为公共
- **class默认权限为私有**


### Q5: 指针与引用的区别

1. 定义方式不同：指针变量的定义需要指明指针类型和变量名，例如：int* p；而引用的定义需要使用 & 符号将变量名和引用类型组合在一起，例如：int& r = a；
2. 内存占用不同：指针变量本身需要占用内存，而引用本身不需要占用内存，因为引用就是一个别名，它与被引用的变量实际上指向同一块内存空间；
3，空值处理不同：指针可以为空，也可以指向空指针，而引用必须初始化，并且不能指向空值；
4. 操作符重载不同：可以重载指针的操作符（如 * 和 ->），以访问指针所指向的对象；而引用不能重载操作符；
5. 可以有多级指针，但没有多级引用，即指针可以指向指针，也可以指向指向指针的指针，但引用只能指向一个变量；
6. 可以改变指向：指针可以随时改变指向，即可以指向不同的变量或者空间，而引用一旦被初始化后，就不能再指向其他变量或空；
7. 传递方式不同：指针可以被传递到函数中，函数内对指针的修改会影响原始变量；引用也可以被传递到函数中，但函数内对引用的修改同样会影响原始变量，这是因为引用本身就是原始变量的别名；


### Q6: 继承时，父类的析构函数是否为虚函数？构造函数能不能为虚函数？为什么？

继承时，父类的析构函数需要为虚函数，构造函数不能为虚函数。

析构函数需要为虚函数：
1. 因为析构时，需要触发动态多态，期间不仅需要调用父类的析构函数，还需要调用子类的析构函数，以避免子类的内存泄露。
2. 如果父类的析构函数是虚函数，则子类的析构函数一定是虚函数（即使是子类的析构函数不加virtual,这是C++的语法规则）

构造函数不能为虚函数：
从vptr角度解释
虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针(vptr可以参考C++的虚函数表指针vptr)指向，该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，但此时vptr还没有初始化！

从多态角度解释
虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。
在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数


### Q7: 虚函数实现动态多态的原理

当一个类中出现虚函数或着子类继承了虚函数时，就会在该类中产生一个虚函数表（virtual table），
虚函数表实际上是一个函数指针数组（在有的编译器作用下是链表），
里面的每一个元素对应指向该类中的某一个虚函数的指针。
被该类声明的对象会包含一个虚函数表指针（virtual table pointer），指向该类的虚函数表的地址。


### Q8: 虚函数与纯虚函数的区别

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。


### 栈分配与堆分配

栈分配
	MyLinkedList a(1);

堆分配
	MyLinkedList* a = new MyLinkedList(1);


### delete与delete[]的区别

	// delete 操作符用于释放通过 new 分配的单个对象。
	char* data = new char; // 分配单个字符的内存
	*data = 'A';
	delete data; // 释放内存

	// delete[] 操作符用于释放通过 new[] 分配的数组。
	char* data = new char[10]; // 分配10个字符的内存
	data[0] = 'A';
	data[1] = 'B';
	// 其他初始化操作
	delete[] data; // 释放数组内存









